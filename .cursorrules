Create a repository in my github: Chrijaque

Blurd.chat is a peer-to-peer webcam platform where users can connect with random peers. Initially, both users’ faces and usernames are blurred. Users can chat via text, toggle their microphone, and send requests to unblur. 
If both users agree, the blur is removed, and they can see each other, adding a unique reward element to the interaction. 
The platform also allows users to earn coins for meaningful connections, track their progress, and build a list of friends they’ve made.

	Queue system
To prioritize matching users of approximately the same age, you can implement a matching algorithm that assigns higher priority to users whose ages are closer. Here’s a step-by-step approach to implementing this logic:

1. Organize Users by Age and Gender

Store user data with age as a key parameter:

Matchmaking Algorithm

 - Calculate Age Difference

When a user requests a match:
	1.	Fetch other users currently available for a chat.
	2.	Compute the absolute age difference:

2. Prioritize Matches by Age Difference

Sort potential matches by age difference:
	•	Users with the smallest age difference are prioritized.
	•	Example logic: potential_matches = sorted(available_users, key=lambda user: abs(current_user['age'] - user['age']))

	Exclusions: Avoid matching the same user repeatedly within a short time frame.
	•	Preferences: Consider user preferences, such as maximum acceptable age difference.


3. Dynamic Age Range Logic (Optional)

Create more nuanced logic for different age groups, adjust the acceptable age difference based on the user’s age:
	•	Younger Users (e.g., Age < 18): Narrow range, e.g., ±2-3 years.
	•	Middle-aged Users (e.g., 18-50): Moderate range, e.g., ±15 years.
	•	Older Users (e.g., >50): Wider range, e.g., ±10 years.


4. Real-Time Matching Flow

	1.	User Joins Queue:
	•	When a user is ready to chat, add them to a matchmaking queue.
	2.	Fetch Available Users:
	•	Pull users currently waiting for a match.
	3.	Sort and Filter Matches:
	•	Calculate age differences.
	•	Sort by smallest age difference.
	•	Apply additional filters.
  •	Match gender, male with female, female with male. If no Gender ignore Match gender.
	4.	Match the Top Priority User:
	•	Select the best match and remove both users from the queue.

5. Scalability Considerations

If the user base grows, prioritize efficiency:
	•	Use a priority queue (e.g., heap) to dynamically prioritize users by age difference.
	•	Consider caching frequently matched users to reduce database queries.

6. Handle Edge Cases

	•	No Close Matches: Allow a fallback to match with users outside the preferred range if no suitable match exists.
	•	Very Few Active Users: Relax the filters dynamically over time.

	Coin system
Base Earning:
	•	Peers earn 1 coin per minute of chat time, starting after the first 5 minutes.
	•	Coins are accumulated only until unblur occurs or up to a maximum of 1 hour.
	2.	Unblur Bonus:
	•	When peers mutually unblur, each gets a bonus of 15 coins.
	•	Once unblurred, further coin accumulation stops.
	•	Rule 1 still applies, meaning peers earn 1 coin per minute after the 5-minute threshold, up until the unblur action.
	3.	Exceptions:
	•	No coins are earned during the first 5 minutes of any chat session.

Technical Implementation

Frontend:

	1.	Timer Logic:
	•	Start a timer at the beginning of the chat session.
	•	Track elapsed time in seconds.
	•	Update the coin count:
	•	After 5 minutes, increment the coin counter by 1 every minute.
	•	Stop counting coins after unblur or at the 60-minute mark.
	2.	Trigger Unblur:
	•	On unblur, send the action to the backend to calculate the bonus and stop coin accumulation.
	3.	Display:
	•	Show a real-time coin counter in the header for both the current session and the user’s total wallet.

Backend:

	1.	Session Tracking:
	•	Store session start time and elapsed time in Firebase Firestore.
	•	Use WebSocket events to track unblur actions and calculate coins in real-time.
	2.	Coin Calculation:
	•	When the session ends or unblur occurs:
	•	Compute earned coins:
	•	 \text{Total Time} - 5 \, \text{minutes (threshold)} 
	•	Apply 1 coin per minute rule until unblur or 60-minute cap.
	•	Add 15 coins if unblurred.
	3.	Database Updates:
	•	Update user wallets and session logs for auditing.

  Unblur Functionality
1. Sending an Unblur Request

	•	When a peer clicks the Unblur button:
	•	A notification is immediately sent to the other peer’s chat, asking “Peer X wants to remove the blur. Do you accept?”
	•	This uses WebSocket (Socket.IO) to send the request in real time.

2. Button State Change

	•	After sending the request:
	•	The Unblur button changes to display “Waiting for Peer” or similar.
	•	The button becomes disabled to prevent multiple requests while waiting.

3. Accepting the Request

	•	When the other peer accepts:
	•	Blur is removed on both peers’ screens using the CSS Filters (filter: blur()).
	•	Both peers see a message in the chat box: “Congratulations – you can now see each other!”
	•	Unblur button get's disabled.
  •	Peers get added to eachothers friends list with username. 

4. Blur Effect

	•	The blur effect applies to the entire screen, ensuring no part of the video and username is visible until consent is mutual.
	•	This is implemented using CSS Filters (filter: blur()).

Workflow for Unblur Interaction

	1.	Peer 1 Clicks Unblur:
	•	Trigger a WebSocket event: sendUnblurRequest(peerId).
	•	Peer 2 receives a chat message: “Peer X wants to remove the blur. Do you accept?”
	•	Peer 1’s Unblur button changes to “Waiting for Peer” and is disabled.
	2.	Peer 2 Accepts:
	•	Peer 2 clicks Accept on the notification.
	•	Trigger another WebSocket event: acceptUnblurRequest(peerId).
	•	Blur is removed on both screens.
	•	Chat box message: “Congratulations – you can now see each other!”
	3.	Backend Support:
	•	Use Socket.IO to manage real-time messages between peers.
	•	Maintain state on the backend to track which peer initiated the unblur request.

	1.	Unblur Button Design:
	•	Default State: “Unblur”.
	•	After Click: Changes to “Waiting for Peer”, with a subtle animation (e.g., dots and color change).
	•	Disabled State: Prevents duplicate clicks.
	2.	Notification in Chat:
	•	Peer 2 gets a clear prompt to accept or decline.
	•	Accept button triggers blur removal for both.
	3.	Full-Screen Blur:
	•	Apply a CSS filter: blur(10px) to the entire video container.
	•	On unblur, remove the blur effect from the container.


1.	Frontend:
	•	Button State: Use React state to manage button text and disable it after clicking.
	•	Chat Notification: Append messages to the chat box dynamically via WebSocket events.
	•	Blur Control: Use CSS filters for full-screen blur; fallback to a solid overlay for less capable devices.
	2.	Backend:
	•	Use Socket.IO to:
	•	Emit unblurRequest and unblurAccept events between peers.
	•	Maintain session state (who sent the request and its status).
	3.	Visual and Interaction Design:
	•	Notification messages styled for clarity and prominence.
	•	Subtle button animations (e.g., dots and color change) to indicate waiting state.

Comprehensive Functional and Design Plan
1. Landing Page

	•	URL: https://blurd.chat
	•	Features:
	•	A video stream window placeholder.
	•	A button labeled “Start Blurd Chat”.
	•	Behavior:
	•	If signed in:
	•	Prompt users to agree to microphone and webcam usage (via MediaDevices API).
	•	Redirect to chat after consent.
	•	If not signed in:
	•	Display a pop-up for sign-up or sign-in using Firebase Authentication.
	•	Sign-up requires:
	•	Username (unique validation via Firestore).
	•	Age.
	•	Gender (with an option for “Prefer Not to Say”).

  2. Pre-Chat Agreement

	•	Terms and Conditions:
	•	Users must accept Terms and Conditions before starting a chat, add link to Terms and Conditions page.
	•	Button remains disabled until checked.
	•	Start Blurd Chat enables when user accepts Terms and Conditions

  3. Chat Section

	•	Layout:
	•	Two video streams:
	•	One for the local peer.
	•	One for the remote peer.
	•	Three buttons below the streams:
	1.	Next: Adds the user back to the queue system and matches with a new peer.
	2.	End: Ends the session and redirects to the front page.
	3.	Unblur: Sends an unblur request to the remote peer as per the Unblur Functionality.
	•	Additional Features:
	•	A Report button:
	•	Includes a drop-down menu for reporting options (e.g., harassment, inappropriate behavior).
	•	Submit reports via the backend and log them in a Firestore database for admin review.

4. Header

	•	Visibility:
	•	Always visible across all pages.
	•	Functionality:
	•	Includes the logo. Clicking the logo redirects to the front page.

5. Vertical Menu Bar

	•	Sections:
	•	Profile Info:
	•	Display username, age, and gender.
	•	A settings icon to modify profile details (username, age, and gender).
	•	Coins Tracker:
	•	Displays total coins earned.
	•	Friends List:
	•	Shows peers added via unblurring.
	•	Clicking a friend initiates a direct connection via the queue system.

6. Footer

	•	Links:
	•	Terms and Conditions: Static link to legal information.
	•	Contact Form: Opens a form for reporting technical issues or other inquiries.

7. Settings

	•	Functionality:
	•	Accessed via the vertical menu bar.
	•	Displays a pop-up form:
	•	Fields for username, age, and gender (optional).
	•	A Save button updates changes in the Firestore database.

  7. Settings

	•	Functionality:
	•	Accessed via the vertical menu bar.
	•	Displays a pop-up form:
	•	Fields for username, age, and gender (optional).
	•	A Save button updates changes in the Firestore database.

  Key Tools for Implementation

Frontend

	•	Framework: Next.js (React-based, for fast rendering and SEO).
	•	UI Styling: Tailwind CSS (responsive and modern design).
	•	Video Streaming: MediaDevices API (for webcam and microphone access).

Backend

	•	Framework: Node.js with Express.js.
	•	Database: Firebase Firestore (to store user profiles, reports, friends, and coins).
	•	Authentication: Firebase Authentication (supports Google, Facebook, Apple, and email/password logins).

Real-Time Communication
	•	Technology: WebRTC (for peer-to-peer video and audio streams).
	•	Signaling: Socket.IO (to exchange WebRTC signaling data).
	•	Queue System: Backend logic for matching peers.

Blur/Unblur

	•	CSS-based full-screen blur


Additional Design Details

	•	Color Scheme: Gender-neutral, age-inclusive (soft greens, blues, and purples).
	•	Report Feature:
	•	Dropdown with categories (e.g., harassment, inappropriate content).
	•	Logs submitted reports to the backend.
	•	Responsive Design:
	•	Fully functional on desktop and mobile.

Deployment

	•	Frontend: Deploy on Vercel for seamless Next.js hosting.
	•	Backend: Deploy the Node.js server on Digital Ocean.
	•	TURN/STUN Servers: Use Coturn for WebRTC connectivity.

Credentials
Firebase
{
  "type": "service_account",
  "project_id": "blurdchat",
  "private_key_id": "f9f4aa33203a6093b420c58ddf2dbc7bc0998e2f",
  "private_key": "-----BEGIN PRIVATE KEY-----\nMIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCoqmf3u89bq5mF\nPgEaqKV/s2NMjKYyXD31/FFWRtgSrByOpoTPOOrKNQXPBHorBa/YzmGtL9ZiVdmU\niBskT+HanRGFFYEx78dANwKQCOalTqyyrXZkrt+ap58++7AoM+MM8WEsFhUlaz+K\n+qDqwF7nbDcubVrq+lpQtSeYBJYwIKC7PpFoYl/LdQ6Bktmz1m7h+cDb2GbOv6eC\nMkF3MjqUyWGcDJRlf3ncioer580evBKOcMUR7T6LMwktiyVLNekKTQfCnbWsou+r\nPIkvd7pL5aOrFyAiOrgJiLKoVILN4YoeX9AKB9dIDL+rrppK/7FI7XpeMxbYbUm+\nNbPaQ2svAgMBAAECggEAAn1RajSuy4RC5daTyZhHqRTgGFcodNcrtZ/Idjo2zOps\nGXxCZZSffTs/H1504dcEUMeVutVZQrulqdhAc6QXif8w161eP3scjnQWvkLYtK6Z\nRKHkJ3mf+fZowVM8YbuHqb8+V0TpgaiNmDg5e9LkaQy4hnToF055WsucZAAH/3nV\nn8mGfVGMGJpcCwBwINcK4xkFMcMCShIIgVzmI8hwyZq+dZJmLoa28xOwT3hod3vs\n4aiFFBThQujCR6+txvEeKPs8bNuPIPSelQ1X87wzug/TRJ0rTKYiOONAetJ4AIy+\n5cjrWpAMuZMqgqAw2PSj9x+yzdnKtoS1ebZ+NxolQQKBgQDtfYshLeHjSeW392QF\nJaGpEJaUw4Y7dTWdsLOq10a/oiy8Nyw58d1sqSUUlLHbZ6XjehlHsStokn06kNJ8\nGkDq6Wfwkc4GgtSG/YZvu2ikwe1cYG2Af3+lK+rFmtrhGcDSJEd6IfkZQaPdjhtT\nfUM9dHG61Wr3EM3r3XF38rCFMQKBgQC1z6hABCbWn0GJsnVHmj8T8HatvZUF1l3H\nSZ/ji0zlJYw4oSoqkhg41YsDzzaqpHUu1jhrZjzOFoWA3Xtnv3O7Dw8PwXzxMDly\npUMndW34LoVsZvO/Q8j1Ia6AWiXJIX4yR2t8VDDOLfV5uVqbAp/Nsf34/k2IUhjA\nkTR2aPpeXwKBgDKlSz5QIpPt9mc9Ar92Pvtm5jXjXIThggWW4TnVnujPFOsueOgC\nhE3f5GB3NVasy9uu9iUryy4Jz1rl930vvBhcniXXcjBBRkFjX4AEX1SDZrMEfVWh\n2v7GVtK9K2BFtbEau4N4Kz8PmHpvC7TKScSZSIena6A0nTVnjAMgZjSBAoGBAKSz\nNh6v5CMe5/b+ZEH2GFhOyKQBjwNXu2JybtZp9cHLrugKD7G64RhzUlikGUiibMl+\nJGQenMyxGEWx3j4Q8J0vOhyy0iWH4zLZRSl0tqdSNWoLJZpJpL1zwqnhgENhBPo1\nOsjJV+EfPzYC1HKCARQMvx8V+FSa0nN31wfBd7WPAoGASoeXrEIOteIRWwek2Wh8\nRidALS1v4sTHla6pUecWU8Q2eNfN9IGoSKodzyfHfDu5zB9W/CO8un4JMEAgrY8g\n7vlf9+Idr6ZCBT4eIxzZWfAZTjtHkAMSvx3T8S8JkLoqtyUZEZInh9hfjQw/+v43\nOF5Xxn0k2j1kNCGDKPEdEjs=\n-----END PRIVATE KEY-----\n",
  "client_email": "firebase-adminsdk-6cccp@blurdchat.iam.gserviceaccount.com",
  "client_id": "113658488940017340254",
  "auth_uri": "https://accounts.google.com/o/oauth2/auth",
  "token_uri": "https://oauth2.googleapis.com/token",
  "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
  "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/firebase-adminsdk-6cccp%40blurdchat.iam.gserviceaccount.com",
  "universe_domain": "googleapis.com"
}
Firebase
APIKEY: AIzaSyA8Pam2UO9Yk3n3DMWaZFqV8D9-o7EQddA

Google STUN Server: stun:stun.l.google.com:19302
Google Auth client: 947196596809-qqtq7nti6sfp5pmbcqen9v750684o9eo.apps.googleusercontent.com

Digital Ocean
IPv4: 207.154.254.52
password: juliaCobo!96erSEXY
Droplet name: nodejs